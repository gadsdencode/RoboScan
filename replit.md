# ROBOSCAN - Website Scanner Application

## Overview

ROBOSCAN is a web application that scans websites for robots.txt and llms.txt files, analyzing bot permissions and providing detailed reports. The application features a cyberpunk-themed UI and allows users to input a URL to receive instant analysis of how the website handles bot crawling permissions.

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Frontend Architecture

**Framework**: React with TypeScript using Vite as the build tool and development server.

**UI Component Library**: The application uses shadcn/ui (new-york style variant) with Radix UI primitives for accessible, customizable components. The design system is built on Tailwind CSS with custom theming and CSS variables for consistent styling.

**State Management**: TanStack Query (React Query) handles server state management, providing caching, background updates, and request deduplication. The query client is configured with custom error handling and disabled automatic refetching.

**Routing**: Wouter provides lightweight client-side routing with a simple Switch/Route pattern.

**Styling Approach**: Custom Tailwind theme with a cyberpunk aesthetic featuring cyan neon accents on a dark background. The theme uses CSS custom properties for color management and includes custom animation utilities.

### Backend Architecture

**Server Framework**: Express.js running on Node.js with TypeScript, configured as an ES module.

**API Design**: RESTful API with endpoints for:
- Scanning: `/api/scan` (POST) - One-time scans, works with/without auth
- Payments: `/api/create-payment-intent`, `/api/confirm-payment` - Stripe integration for premium reports
- Auth: `/api/auth/user`, `/api/login`, `/api/logout` - Replit Auth endpoints
- Recurring Scans: `/api/recurring-scans` (CRUD) - Scheduled automated scans
- Notifications: `/api/notifications` (GET/PATCH) - Change alerts from recurring scans
Request validation uses Zod schemas for type-safe input validation.

**Development vs Production**: In development, Vite middleware integrates with Express for hot module replacement. In production, the server serves static files from the built client bundle.

**Storage Layer**: `DatabaseStorage` implements `IStorage` interface using Drizzle ORM with PostgreSQL. Supports:
- User management (Replit Auth integration)
- Scan CRUD with ownership tracking
- Purchase tracking for premium reports
- Recurring scan scheduling and management
- Notification preferences and delivery
All database operations use Drizzle's type-safe query builder.

**Scanner Logic**: Custom website scanner fetches and parses robots.txt and llms.txt files from target domains. It normalizes URLs, handles timeouts, extracts bot permissions, and returns structured results with errors and warnings.

**Change Detection**: Compares previous and current scan results to identify:
- robots.txt content changes
- llms.txt content changes
- Bot permission modifications
- New errors introduced
Used by recurring scans to trigger notifications.

**Scheduler**: Background process runs every minute to:
- Identify due recurring scans based on nextRunAt
- Execute scans automatically
- Detect changes using change detector
- Create notifications based on user preferences
- Update scan schedules for next run

### Data Storage Solutions

**Current Implementation**: In-memory storage using Map data structures for both users and scans. This provides fast access during development but data is lost on server restart.

**Schema Definition**: Drizzle ORM with PostgreSQL dialect defines the data model. Main tables:
- `users`: Replit Auth user data (id, email, profile info)
- `sessions`: PostgreSQL-backed session storage for Replit Auth
- `scans`: Scan results including URL, robots.txt/llms.txt content, bot permissions, errors, warnings (linked to users)
- `purchases`: Stripe payment tracking for premium reports (linked to scans)
- `recurringScans`: Automated scan schedules with frequency settings (daily/weekly/monthly)
- `notificationPreferences`: User notification settings for recurring scans
- `notifications`: Change alerts generated by recurring scans

**Migration Strategy**: Drizzle Kit manages schema migrations with the output directory set to `./migrations`.

**Database Configuration**: Environment variable `DATABASE_URL` required for PostgreSQL connection via Neon serverless driver.

### Authentication and Authorization

**Implementation**: Replit Auth via OpenID Connect provides Google/GitHub/email login. Session data persists in PostgreSQL via `connect-pg-simple`. All protected routes use `isAuthenticated` middleware.

**Authorization**: Scans link to users via `userId`. Payment and recurring scan endpoints verify ownership before allowing access.

### External Dependencies

**Database Service**: Neon Serverless PostgreSQL via HTTP driver (`drizzle-orm/neon-http` with `@neondatabase/serverless`).

**Payment Processing**: Stripe integration for $9.99 one-time payments to unlock premium reports. Works for both authenticated and anonymous users.

**Development Tools**: 
- Replit-specific Vite plugins for runtime error overlay, cartographer, and dev banner
- Drizzle Kit for database migrations and schema management
- tsx for TypeScript execution in development

**UI Dependencies**:
- Complete Radix UI primitive library for accessible components
- Lucide React for iconography
- TailwindCSS with @tailwindcss/vite plugin
- class-variance-authority for variant-based component styling
- Various form handling libraries (react-hook-form, @hookform/resolvers)

**Font Loading**: Google Fonts integration loading Architects Daughter, DM Sans, Fira Code, and Geist Mono font families.