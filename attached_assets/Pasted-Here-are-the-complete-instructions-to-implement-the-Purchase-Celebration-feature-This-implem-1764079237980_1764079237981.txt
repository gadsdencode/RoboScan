Here are the complete instructions to implement the **Purchase Celebration** feature.

This implementation adds a high-impact visual reward immediately after a successful payment, validating the user's financial commitment and creating a "peak moment" in the user experience.

### **Step 1: Install Dependencies**

You need to install the `canvas-confetti` library and its TypeScript definitions.

**Command:**

```bash
npm install canvas-confetti
npm install -D @types/canvas-confetti
```

-----

### **Step 2: Update Payment Modal Component**

We will modify the `CheckoutForm` within the modal to trigger the confetti effect exactly when the payment is confirmed by the backend.

**File:** `client/src/components/PaymentModal.tsx`

**1. Add the import** at the top of the file:

```typescript
import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { X, Check, Lock, Sparkles, TrendingUp, FileText, Zap } from "lucide-react";
import { Elements, PaymentElement, useStripe, useElements } from "@stripe/react-stripe-js";
import { loadStripe } from "@stripe/stripe-js";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
// [GAMIFICATION] Import confetti
import confetti from "canvas-confetti"; 
```

**2. Define the celebration trigger function** just before the `CheckoutForm` component (or inside it):

```typescript
// [GAMIFICATION] Premium Unlock Celebration
const triggerPurchaseConfetti = () => {
  const duration = 3 * 1000;
  const animationEnd = Date.now() + duration;
  const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 9999 };

  const randomInRange = (min: number, max: number) => {
    return Math.random() * (max - min) + min;
  };

  const interval: any = setInterval(function() {
    const timeLeft = animationEnd - Date.now();

    if (timeLeft <= 0) {
      return clearInterval(interval);
    }

    const particleCount = 50 * (timeLeft / duration);
    
    // Since particles fall, spawn a bit higher than random
    confetti({
      ...defaults,
      particleCount,
      origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
    });
    confetti({
      ...defaults,
      particleCount,
      origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
    });
  }, 250);
};
```

**3. Inject the trigger in `CheckoutForm`** within the `handleSubmit` function:

Locate the `handleSubmit` function inside `CheckoutForm` and update the success block:

```typescript
// Inside CheckoutForm component...

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!stripe || !elements) {
      return;
    }

    setIsProcessing(true);
    setError(null);

    try {
      const { error: submitError, paymentIntent } = await stripe.confirmPayment({
        // ... existing config ...
      });

      if (submitError) {
        // ... existing error handling ...
      } else if (paymentIntent && paymentIntent.status === 'succeeded') {
        const response = await fetch('/api/confirm-payment', {
          // ... existing fetch config ...
        });

        if (response.ok) {
          // [GAMIFICATION] Trigger celebration before closing
          triggerPurchaseConfetti();
          onSuccess();
        } else {
          setError('Payment succeeded but confirmation failed. Please contact support.');
        }
        setIsProcessing(false);
      }
    } catch (err) {
      // ... existing error handling ...
    }
  };
```

### **Summary of Changes**

  * **Visuals:** Upon successful payment, users are greeted with a 3-second dual-cannon confetti burst from the corners of the screen.
  * **Timing:** The effect triggers *immediately* when the server confirms the transaction, bridging the gap between the payment modal closing and the new content loading.
  * **Implementation:** Used `canvas-confetti` because it renders to a separate canvas layer `zIndex: 9999`, ensuring the celebration is visible even as the React component tree (the modal) unmounts.